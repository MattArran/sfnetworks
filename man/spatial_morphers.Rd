% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/morphers.R
\name{spatial_morphers}
\alias{spatial_morphers}
\alias{to_spatial_coordinates}
\alias{to_spatial_dense}
\alias{to_spatial_directed}
\alias{to_spatial_explicit_edges}
\alias{to_spatial_implicit_edges}
\alias{to_spatial_shortest_paths}
\alias{to_spatial_simple}
\alias{to_spatial_sparse}
\alias{to_spatial_subset}
\title{Spatial morphers for sfnetworks}
\usage{
to_spatial_coordinates(x)

to_spatial_dense(x)

to_spatial_directed(x)

to_spatial_explicit_edges(x)

to_spatial_implicit_edges(x)

to_spatial_shortest_paths(x, ...)

to_spatial_simple(x, keep = "shortest", ...)

to_spatial_sparse(x, require_equal_attrs = FALSE)

to_spatial_subset(x, ..., subset_by = NULL)
}
\arguments{
\item{x}{An object of class \code{\link{sfnetwork}}.}

\item{...}{Arguments to be passed on to other functions. See the description
of each morpher for details.}

\item{keep}{Which geometry should be preserved when collapsing parallel
edges. Either \code{"longest"} or \code{"shortest"}. Defaults to
\code{"shortest"}.}

\item{require_equal_attrs}{Should pseudo nodes only be removed when all
attributes of their incident edges are equal? Defaults to \code{FALSE}.}

\item{subset_by}{Whether to create subgraphs based on nodes or edges.}
}
\value{
Either a \code{morphed_sfnetwork}, which is a list of one or more
\code{\link{sfnetwork}} objects, or a \code{morphed_tbl_graph}, which is a
list of one or more \code{\link[tidygraph]{tbl_graph}} object. See the
description of each morpher for details.
}
\description{
Spatial morphers form spatial add-ons to the set of
\code{\link[tidygraph]{morphers}} provided by \code{tidygraph}. These
functions are not meant to be called directly. They should either be passed
into \code{\link[tidygraph]{morph}} to create a temporary alternate
representation of the input network. Such an alternate representation is a
list of one or more network objects. Single elements of that list can be
extracted directly as a new network by passing the morpher to
\code{\link[tidygraph]{convert}} instead. Alternatively, if the morphed
state contains multiple elements, all of them can be extracted together
inside a \code{\link[tibble]{tibble}} by passing the morpher to
\code{\link[tidygraph]{crystallise}}.
}
\details{
It also possible to create your own morphers. See the documentation
of \code{\link[tidygraph]{morph}} for the requirements for custom morphers.
}
\section{Functions}{
\itemize{
\item \code{to_spatial_coordinates}: Store the spatial coordinates of the nodes in
separate coordinate columns, instead of a \code{\link[sf]{sfc}} geometry
list column. If edges are spatially explicit, the edge geometries are
dropped. Returns a \code{morphed_tbl_graph} containing a single element of
class \code{\link[tidygraph]{tbl_graph}}.

\item \code{to_spatial_dense}: Reconstruct the network by treating all points
that shape geometries of edge linestrings as nodes, instead of only the
endpoints. Returns a \code{morphed_sfnetwork} containing a single element of
class \code{\link{sfnetwork}}. This morpher requires edges to be spatially
explicit.

\item \code{to_spatial_directed}: Make a network directed in the direction given
by the linestring geometries of the edges. Differs from
\code{\link[tidygraph]{to_directed}}, which makes a network directed based
on the node indices given in the \code{from} and \code{to} columns. In
undirected networks these indices may not correspond with the endpoints of
the linestring geometries. Returns a \code{morphed_sfnetwork} containing a
single element of class \code{\link{sfnetwork}}. This morpher requires edges
to be spatially explicit. If not, use \code{\link[tidygraph]{to_directed}}.

\item \code{to_spatial_explicit_edges}: Draw linestring geometries between from and to
nodes of spatially implicit edges. Returns a \code{morphed_sfnetwork}
containing a single element of class \code{\link{sfnetwork}}.

\item \code{to_spatial_implicit_edges}: Remove linestring geometries of spatially
explicit edges. Returns a \code{morphed_sfnetwork} containing a single
element of class \code{\link{sfnetwork}}.

\item \code{to_spatial_shortest_paths}: Limit a network to those nodes and edges that
are part of the shortest path between two nodes. \code{...} is evaluated in
the same manner as \code{\link{st_shortest_paths}}. Returns a
\code{morphed_sfnetwork} that may contain multiple elements of class
\code{\link{sfnetwork}}, depending on the number of requested paths. When
unmorphing only the first instance of both the node and edge data will be
used, as the the same node and/or edge can be present in multiple paths.

\item \code{to_spatial_simple}: Remove loops in a graph and collapse parallel
edges. \code{...} is passed on to \code{\link[tidygraph]{to_simple}}.
Differs from \code{\link[tidygraph]{to_simple}} by assigning a single
linestring geometry to combined parallel edges. This is either the geometry
of the shortest or the longest of the parallel edges. Returns a
\code{morphed_sfnetwork} containing a single element of class
\code{\link{sfnetwork}}. This morpher requires edges to be spatially
explicit. If not, use \code{\link[tidygraph]{to_simple}}.

\item \code{to_spatial_sparse}: Reconstruct the network by iteratively removing
pseudo nodes, while preserving the connectivity of the network. In the case
of directed networks, pseudo nodes are those nodes that have only one
incoming and one outgoing edge. In undirected networks, pseudo nodes are
those nodes that have two incident edges. Connectivity of the network is
preserved by merging the incident edges of each removed pseudo node. Returns
a \code{morphed_sfnetwork} containing a single element of class
\code{\link{sfnetwork}}.

\item \code{to_spatial_subset}: Subset the network by applying a spatial
filter, i.e. a filter on the geometry column based on a spatial predicate.
\code{...} is evaluated in the same manner as \code{\link{st_filter}}.
Returns a \code{morphed_sfnetwork} containing a single element of class
\code{\link{sfnetwork}}. For filters on an attribute column, use
\code{\link[tidygraph]{to_subgraph}}.
}}

\examples{
library(sf)
library(tidygraph)

net = as_sfnetwork(roxel, directed = FALSE) \%>\%
    st_transform(3035)

net \%>\%
    convert(to_spatial_coordinates)

par(mar = c(1, 1, 1, 1), mfrow = c(1,2))
plot(net)
net \%>\%
    convert(to_spatial_dense) \%>\%
    plot()

net \%>\%
  activate("edges") \%>\%
  st_reverse() \%>\%
  convert(to_spatial_directed)

par(mar = c(1, 1, 1, 1), mfrow = c(1,2))
plot(net)
net \%>\%
 convert(to_spatial_implicit_edges) \%>\%
 convert(to_spatial_explicit_edges) \%>\%
 plot()

net \%>\%
 convert(to_spatial_implicit_edges)

net \%>\%
  convert(to_spatial_shortest_paths, 171, 190)

# Plot shortest paths:
par(mar = c(1, 1, 1, 1), mfrow = c(1,1))
plot(net)
plot(
  net \%>\% convert(to_spatial_shortest_paths, 171, 190),
  col = "red",
  add = TRUE
)

# Calculate lengths of multiple shortest paths
net \%>\%
 activate("edges") \%>\%
 morph(to_spatial_shortest_paths, 1, c(171, 190)) \%>\%
 sapply(function(x) sum(st_length(x)))

# Original number of edges
net \%>\%
  activate("edges") \%>\%
  st_as_sf() \%>\%
  nrow()
# Simplify parallel edges
net \%>\%
  activate("edges") \%>\%
  convert(to_spatial_simple) \%>\%
  st_as_sf() \%>\%
  nrow()

netw = as_sfnetwork(roxel[c(4, 5, 8), ], directed = FALSE)
# Remove pseudo nodes
netw_sparse1 = tidygraph::convert(netw, to_spatial_sparse)
# Only merge edges when their attributes are equal
netw_sparse2 = tidygraph::convert(netw, to_spatial_sparse, require_equal_attrs = TRUE)
# Compare results
par(mar = c(1, 1, 1, 1), mfrow = c(1,3))
plot(netw, cex = 3, main = "Network with pseudo nodes")
plot(netw_sparse1, cex = 3, main = "Pseudo nodes removed")
plot(netw_sparse2, cex = 3, main = "Only edges with equal attributes merged")

e1 = st_point(c(7.53173, 51.95662))
e2 = st_point(c(7.53173, 51.95190))
e3 = st_point(c(7.53778, 51.95190))
e4 = st_point(c(7.53778, 51.95662))

rect = st_multipoint(c(e1, e2, e3, e4)) \%>\%
  st_cast('POLYGON') \%>\%
  st_sfc(crs = 4326) \%>\%
  st_transform(3035)

net \%>\%
  convert(to_spatial_subset, rect, .predicate = st_intersects)
}
